```txt
例え：宅配便の伝票
 あなたの部屋（＝ドメインモデル）には、家具や本、生活用品（＝内部の本当のデータ）がたくさんあります
 でも、宅配業者（＝外部API）には全部見せる必要はないし、見せたら困るものもある
 荷物を送るとき、宅配便の伝票（＝DTO）に必要な情報だけ書きます

送り先住所
 名前
 電話番号
 部屋の中身（パスワードや内部IDなど）は絶対に載せない

なぜ変換が必要か
 安全性
   内部の構造や機密情報を直接外に出すと、セキュリティ事故や意図しない依存が発生する
   例：PasswordHash がAPIレスポンスに混じって漏れる

 柔軟性
   外部仕様（APIやDB）が変わっても、中のモデルをそのまま変えなくていい
   外と中を変換層（DTO）でつなぐことで、片方だけ変更できる

 責務の分離
   ドメインモデルはビジネスルールを持つ
   DTOはただの入出力用データ
   役割を分けることで、コードの意図がわかりやすくなる

今のあなたのコードとの関係
  domain.User は「アプリ内部のルールを持つ入れ物」
  API レスポンス用に UserResponseDTO を作れば「外部公開用の入れ物」になる
  それぞれが変換（adaptやtoDTO）を通してつながる
  もしこの変換を省略して全部 db.User をそのまま外に返すと、
  DBカラム名や構造の変更がAPIに直撃
  内部専用のカラムが漏れる危険

DBとアプリとAPIがガッチガチに依存して修正コスト爆上がり
…という未来が待っています。
```


- 「シグネチャ（signature）」は、プログラミングでは関数やメソッドの「署名」のことを指します。
つまり、「この関数はこういう名前で、こういう引数を受け取り、こういう型の値を返すよ」という型や形の宣言部分です。
英語の signature はもともと「署名・サイン」という意味。
ラテン語の signatura（印をつけること）→ signare（印をつける）から来ています。
プログラミングにおける「署名」も、
「関数の外見的な情報を記したサイン（名前と型の組み合わせ）」
というニュアンスで使われています。


- コマンドオブジェクト
コマンドオブジェクト（Command Object）は、**「実行したい処理と、その処理に必要なデータをひとまとめにしたオブジェクト」**です。

```txt
// コマンドのインターフェース
type Command interface {
    Execute()
}

// 実際のコマンド
type CreateUserCommand struct {
    Email string
    Name  string
}

func (c *CreateUserCommand) Execute() {
    fmt.Printf("ユーザ作成: %s (%s)\n", c.Name, c.Email)
}

// 実行側
func main() {
    cmd := &CreateUserCommand{
        Email: "test@example.com",
        Name:  "Taro",
    }
    cmd.Execute() // => ユーザ作成: Taro (test@example.com)
}
```